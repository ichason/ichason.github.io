# CPU 执行流程与寄存器协作关系

## 一、CPU 的基本执行循环（取指-解码-执行）

CPU 的工作就是一个无限循环，不断重复以下步骤：

```
┌─────────────────────────────────────┐
│  1. Fetch（取指）                    │
│     从 PC 指向的内存地址读取指令      │
├─────────────────────────────────────┤
│  2. Decode（解码）                   │
│     解析指令，确定要做什么操作        │
├─────────────────────────────────────┤
│  3. Execute（执行）                  │
│     执行指令（计算、读写内存、跳转等）│
├─────────────────────────────────────┤
│  4. Write Back（写回）               │
│     把结果写回寄存器或内存            │
└─────────────────────────────────────┘
         ↓
    PC += 4（或跳转）
         ↓
    回到步骤 1
```

### 伪代码表示

```c
void cpu_main_loop() {
    while (true) {
        // 1. 取指：从 PC 指向的地址读取指令
        uint32_t instruction = memory[PC];

        // 2. 解码：分析指令类型
        OpCode op = decode(instruction);

        // 3. 执行：根据指令类型执行操作
        switch (op) {
            case ADD:
                R[dest] = R[src1] + R[src2];
                PC += 4;
                break;
            case LOAD:
                R[dest] = memory[address];
                PC += 4;
                break;
            case JUMP:
                PC = target_address;  // 跳转
                break;
            // ...
        }

        // 4. 写回：结果已经在步骤 3 中写入寄存器
    }
}
```

## 二、寄存器的分类和作用

### 1. 程序控制寄存器

```
┌──────────────────────────────────────┐
│ PC (Program Counter)                 │
│ 作用：指向下一条要执行的指令地址      │
│ 特点：CPU 每次都从 PC 读取指令        │
└──────────────────────────────────────┘

┌──────────────────────────────────────┐
│ LR (Link Register)                   │
│ 作用：保存函数返回地址                │
│ 特点：函数调用时自动保存，返回时恢复  │
└──────────────────────────────────────┘

┌──────────────────────────────────────┐
│ CPSR (Current Program Status Reg)   │
│ 作用：保存 CPU 状态标志位             │
│ 包含：零标志(Z)、负标志(N)、进位(C)等 │
└──────────────────────────────────────┘
```

### 2. 数据寄存器

```
┌──────────────────────────────────────┐
│ R0-R12 (通用寄存器)                   │
│ 作用：临时存储数据、函数参数、返回值  │
│ 特点：速度最快，数量有限              │
└──────────────────────────────────────┘

┌──────────────────────────────────────┐
│ SP (Stack Pointer)                   │
│ 作用：指向当前栈顶位置                │
│ 特点：函数调用时自动管理栈空间        │
└──────────────────────────────────────┘
```

## 三、完整的执行流程示例

### 示例代码

```c
int add(int a, int b) {
    int result = a + b;
    return result;
}

int main() {
    int x = add(3, 5);
    return 0;
}
```

### 编译成 ARM 汇编

```asm
main:
    0x1000: PUSH {LR}           ; 保存返回地址
    0x1004: MOV R0, #3          ; 第一个参数 a = 3
    0x1008: MOV R1, #5          ; 第二个参数 b = 5
    0x100C: BL add              ; 调用 add 函数
    0x1010: MOV R0, #0          ; 返回 0
    0x1014: POP {PC}            ; 恢复 PC，返回

add:
    0x2000: ADD R0, R0, R1      ; R0 = R0 + R1
    0x2004: BX LR               ; 返回（PC = LR）
```

### CPU 执行流程详解

```
初始状态：
PC = 0x1000
SP = 0x7FFF0000（栈顶）
LR = 0x0（未初始化）

─────────────────────────────────────────────────────
步骤 1: 执行 PUSH {LR}
─────────────────────────────────────────────────────
1. Fetch:   instruction = memory[0x1000] = PUSH {LR}
2. Decode:  操作 = 压栈
3. Execute:
   SP = SP - 4 = 0x7FFEFFFC
   memory[SP] = LR = 0x0
4. PC = PC + 4 = 0x1004

寄存器状态：
PC = 0x1004
SP = 0x7FFEFFFC
LR = 0x0

─────────────────────────────────────────────────────
步骤 2: 执行 MOV R0, #3
─────────────────────────────────────────────────────
1. Fetch:   instruction = memory[0x1004] = MOV R0, #3
2. Decode:  操作 = 移动立即数
3. Execute: R0 = 3
4. PC = PC + 4 = 0x1008

寄存器状态：
PC = 0x1008
R0 = 3

─────────────────────────────────────────────────────
步骤 3: 执行 MOV R1, #5
─────────────────────────────────────────────────────
1. Fetch:   instruction = memory[0x1008] = MOV R1, #5
2. Decode:  操作 = 移动立即数
3. Execute: R1 = 5
4. PC = PC + 4 = 0x100C

寄存器状态：
PC = 0x100C
R0 = 3
R1 = 5

─────────────────────────────────────────────────────
步骤 4: 执行 BL add（关键：函数调用）
─────────────────────────────────────────────────────
1. Fetch:   instruction = memory[0x100C] = BL add
2. Decode:  操作 = 带链接的跳转
3. Execute:
   LR = PC + 4 = 0x1010  （保存返回地址）
   PC = 0x2000           （跳转到 add 函数）

寄存器状态：
PC = 0x2000  ← 跳转到 add 函数
LR = 0x1010  ← 保存了返回地址
R0 = 3
R1 = 5

─────────────────────────────────────────────────────
步骤 5: 执行 ADD R0, R0, R1（在 add 函数中）
─────────────────────────────────────────────────────
1. Fetch:   instruction = memory[0x2000] = ADD R0, R0, R1
2. Decode:  操作 = 加法
3. Execute: R0 = R0 + R1 = 3 + 5 = 8
4. PC = PC + 4 = 0x2004

寄存器状态：
PC = 0x2004
R0 = 8  ← 计算结果
R1 = 5
LR = 0x1010

─────────────────────────────────────────────────────
步骤 6: 执行 BX LR（关键：函数返回）
─────────────────────────────────────────────────────
1. Fetch:   instruction = memory[0x2004] = BX LR
2. Decode:  操作 = 跳转到 LR
3. Execute: PC = LR = 0x1010  （返回到调用点）

寄存器状态：
PC = 0x1010  ← 返回到 main 函数
R0 = 8       ← 返回值
LR = 0x1010

─────────────────────────────────────────────────────
步骤 7: 执行 MOV R0, #0
─────────────────────────────────────────────────────
1. Fetch:   instruction = memory[0x1010] = MOV R0, #0
2. Decode:  操作 = 移动立即数
3. Execute: R0 = 0
4. PC = PC + 4 = 0x1014

寄存器状态：
PC = 0x1014
R0 = 0

─────────────────────────────────────────────────────
步骤 8: 执行 POP {PC}（程序结束）
─────────────────────────────────────────────────────
1. Fetch:   instruction = memory[0x1014] = POP {PC}
2. Decode:  操作 = 出栈到 PC
3. Execute:
   PC = memory[SP] = 0x0
   SP = SP + 4 = 0x7FFF0000

程序结束（PC = 0 会触发异常或退出）
```

## 四、寄存器之间的协作关系

```
┌─────────────────────────────────────────────────┐
│                  CPU 执行单元                    │
│                                                 │
│  ┌──────┐  ┌──────┐  ┌──────┐  ┌──────┐       │
│  │  PC  │  │  LR  │  │  SP  │  │ CPSR │       │
│  └──┬───┘  └──┬───┘  └──┬───┘  └──┬───┘       │
│     │         │         │         │            │
│     │ 控制    │ 返回    │ 栈管理  │ 状态标志   │
│     │ 执行    │ 地址    │         │            │
│     ↓         ↓         ↓         ↓            │
│  ┌─────────────────────────────────────┐       │
│  │         指令执行逻辑                 │       │
│  │  (ALU 算术逻辑单元)                 │       │
│  └─────────────────────────────────────┘       │
│     ↑         ↑         ↑         ↑            │
│     │         │         │         │            │
│  ┌──┴───┬──┴───┬──┴───┬──┴───┬─────┐         │
│  │  R0  │  R1  │  R2  │ ...  │ R12 │         │
│  └──────┴──────┴──────┴──────┴─────┘         │
│           通用寄存器（数据存储）               │
└─────────────────────────────────────────────────┘
         ↕                    ↕
    ┌─────────┐          ┌─────────┐
    │  内存   │          │  缓存   │
    └─────────┘          └─────────┘
```

### 协作关系说明

1. **PC 是指挥官**
   
   - 决定下一步执行什么指令
   - 所有指令都从 PC 指向的地址读取

2. **LR 是导航员**
   
   - 记住函数调用前的位置
   - 函数返回时告诉 PC 该回到哪里

3. **SP 是仓库管理员**
   
   - 管理栈空间（局部变量、返回地址）
   - 函数调用时自动分配和释放空间

4. **R0-R12 是工人**
   
   - 执行实际的计算工作
   - 传递函数参数和返回值

5. **CPSR 是记录员**
   
   - 记录计算结果的状态（是否为零、是否溢出等）
   - 条件跳转指令会检查这些标志

## 五、Frida 注入时的寄存器劫持

```
正常执行流程：
PC = 0x1000 → 0x1004 → 0x1008 → ...

Frida 注入后：
1. ptrace attach（暂停进程）
   PC = 0x1008（当前位置）

2. 写入 shellcode 到 0x5000
   memory[0x5000] = shellcode

3. 修改 PC 寄存器
   old_pc = 0x1008（保存原来的位置）
   PC = 0x5000（跳转到 shellcode）

4. ptrace continue（恢复执行）
   PC = 0x5000 → 执行 shellcode
   shellcode 调用 dlopen("frida-agent.so")

5. shellcode 执行完毕后恢复
   PC = old_pc = 0x1008（回到原来的位置）
   程序继续正常执行
```

## 六、关键要点总结

1. **CPU 只是机械地执行 PC 指向的指令**
   
   - 不关心指令是正常代码还是注入的 shellcode
   - 只要 PC 指向哪里，就执行哪里的代码

2. **寄存器是 CPU 的"工作台"**
   
   - PC：控制执行流程
   - LR：记住返回地址
   - SP：管理栈空间
   - R0-R12：存储临时数据

3. **修改 PC = 劫持程序执行**
   
   - 这就是 Frida、调试器、exploit 的核心原理
   - 通过修改 PC，可以让程序执行任意代码

4. **寄存器协作完成复杂任务**
   
   - 函数调用：PC 跳转 + LR 保存返回地址 + R0-R3 传参
   - 栈管理：SP 自动调整 + PUSH/POP 指令
   - 条件判断：CPSR 保存标志 + 条件跳转指令
